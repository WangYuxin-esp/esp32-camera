// Copyright 2022-2023 Espressif Systems (Shanghai) PTE LTD
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_attr.h"

#include "sccb.h"
#include "xc7082_gc2053.h"

#if defined(ARDUINO_ARCH_ESP32) && defined(CONFIG_ARDUHAL_ESP_LOG)
#include "esp32-hal-log.h"
#else
#include "esp_log.h"
static const char *TAG = "gc2053";
#endif

#define GC2053_SENSOR_ID_REG_H   0xf0
#define GC2053_SENSOR_ID_REG_L   0xf1

#define GC2053_SENSOR_ID         0x2053
#define REG_DLY                  0xff

static const DRAM_ATTR uint8_t sensor_gc2053_default_regs[][2] = {
    {0xfe,0x80},
    {0xfe,0x80},
    {0xfe,0x80},
    {0xfe,0x00},
    {0xf2,0x00}, //[1]I2C_open_ena [0]pwd_dn
    {0xf3,0x00}, //[3]Sdata_pad_io [2:0]Ssync_pad_io
    {0xf4,0x36}, //[6:4]pll_ldo_set
    {0xf5,0xc0}, //[7]soc_mclk_enable [6]pll_ldo_en [5:4]cp_clk_sel [3:0]cp_clk_div
    {0xf6,0x44}, //[7:3]wpllclk_div [2:0]refmp_div
    {0xf7,0x01}, //[7]refdiv2d5_en [6]refdiv1d5_en [5:4]scaler_mode [3]refmp_enb [1]div2en [0]pllmp_en
    {0xf8,0x63}, //[7:0]pllmp_div
    {0xf9,0x40}, //[7:3]rpllclk_div [2:1]pllmp_prediv [0]analog_pwc
    {0xfc,0x8e},

    /****CISC,TL & ANALOG****/
    {0xfe,0x00},
    {0x87,0x18},
    {0xee,0x30},
    {0xd0,0xb7},

    {0x03,0x01},
    {0x04,0x00},
    {0x05,0x05},//04
    {0x06,0x28},//4c
    {0x07,0x00},
    {0x08,0x11},
    {0x09,0x00}, //[13:0]vb
    {0x0a,0x02}, //cisctl row start
    {0x0b,0x00},
    {0x0c,0x02}, //cisctl col start
    {0x0d,0x04},
    {0x0e,0x40},
    {0x12,0xe2},
    {0x13,0x16},
    {0x17,0x81},
    {0x19,0x0a},

    {0x21,0x1c},
    {0x28,0x0a},
    {0x29,0x24},
    {0x2b,0x04},
    {0x32,0xf8},
    {0x37,0x03},
    {0x39,0x15},
    {0x43,0x07},
    {0x44,0x40},
    {0x46,0x0b},
    {0x4b,0x20},
    {0x4e,0x08},
    {0x55,0x20},
    {0x66,0x05},
    {0x67,0x05},
    {0x77,0x01},
    {0x78,0x00},
    {0x7c,0x93},
    {0x8c,0x12},
    {0x8d,0x92},
    {0x90,0x01}, //00  曝光降帧
    {0x9d,0x10},
    {0xce,0x7c},
    {0xd2,0x41},
    {0xd3,0xdc},
    {0xe6,0x50},

    {0x41,0x04},
    {0x42,0x65},

    /*gain*/
    {0xb6,0xc0},
    {0xb0,0x70},
    {0xb1,0x01},
    {0xb2,0x00},
    {0xb3,0x00},
    {0xb4,0x00},
    {0xb8,0x01},
    {0xb9,0x00},

    /*blk*/
    {0x26,0x30},
    {0xfe,0x01},
    {0x40,0x23},
    {0x55,0x07},
    {0x60,0x10}, //[7:0]WB_offset
    {0xfe,0x04},
    {0x14,0x78},
    {0x15,0x78},
    {0x16,0x78},
    {0x17,0x78},

    /*window*/
    {0xfe,0x01},
    {0x92,0x01}, //win y1   0
    {0x94,0x02}, //win x1   3
    {0x95,0x04},
    {0x96,0x38}, //[10:0]out_height
    {0x97,0x07},
    {0x98,0x80}, //[11:0]out_width

    /*ISP*/
    {0xfe,0x01},
    {0x01,0x05},
    {0x02,0x89},
    {0x04,0x01}, //[0]DD_en
    {0x07,0xa6},
    {0x08,0xa9},
    {0x09,0xa8},
    {0x0a,0xa7},
    {0x0b,0xff},
    {0x0c,0xff},
    {0x0f,0x00},
    {0x50,0x1c},
    {0x89,0x03},

    {0xfe,0x04},
    {0x28,0x86},//84
    {0x29,0x86},//84
    {0x2a,0x86},//84
    {0x2b,0x68},//84
    {0x2c,0x68},//84
    {0x2d,0x68},//84
    {0x2e,0x68},//83
    {0x2f,0x68},//82

    {0x30,0x4f},//82
    {0x31,0x68},//82
    {0x32,0x67},//82
    {0x33,0x66},//82
    {0x34,0x66},//82
    {0x35,0x66},//82
    {0x36,0x66},//64
    {0x37,0x66},//68

    {0x38,0x62},
    {0x39,0x62},
    {0x3a,0x62},
    {0x3b,0x62},
    {0x3c,0x62},
    {0x3d,0x62},
    {0x3e,0x62},
    {0x3f,0x62},

    /****DVP ,& MIPI****/

    {0xfe,0x01},
    {0x9a,0x06},
    {0xfe,0x00},
    {0x7b,0x2a},
    {0x23,0x2d},
    {0xfe,0x03},
    {0x01,0x27},
    {0x02,0x56},
    {0x03,0xce},
    {0x12,0x80},
    {0x13,0x07},
    {0x15,0x10},
    {0xfe,0x00},
    {0x3e,0x91},
    {0xff,0x00}, // tail
};

static int write_regs(uint8_t slv_addr, const uint8_t(*regs)[2], uint32_t entry_len)
{
    int i = 0, ret = 0;
    while (!ret && (i < entry_len)) {
        if (regs[i][0] == REG_DLY) {
            vTaskDelay(regs[i][1] / portTICK_PERIOD_MS);
        } else {
            ret = SCCB_Write(slv_addr, regs[i][0], regs[i][1]);
        }
        i++;
    }
    return ret;
}

// return PID if success, ret 0 if fail.
int gc2053_id_check(void)
{
    uint8_t PID_H = SCCB_Read(GC2053_SCCB_ADDR, GC2053_SENSOR_ID_REG_H);
    uint8_t PID_L = SCCB_Read(GC2053_SCCB_ADDR, GC2053_SENSOR_ID_REG_L);
    uint16_t PID = PID_H << 8 | PID_L;
    if (GC2053_SENSOR_ID != PID) {
        ESP_LOGE(TAG, "Mismatch PID=0x%x", PID);
        return 0;
    }
    ESP_LOGI(TAG, "GC2053 Attached");
    return PID;
}

int gc2053_reset(void)
{
    ESP_LOGI(TAG, "GC2053 reset");
    return write_regs(GC2053_SCCB_ADDR, sensor_gc2053_default_regs, sizeof(sensor_gc2053_default_regs) / (sizeof(uint8_t) * 2));
}
